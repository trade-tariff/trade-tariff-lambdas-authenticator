#! /usr/bin/env node

const { execSync } = require('child_process');
const axios = require('axios');
const { performance } = require('perf_hooks');
const { table } = require('table');
const { v4: uuidv4 } = require('uuid');

(async () => {
  const { default: ora } = await import('ora');
  const { default: chalk } = await import('chalk');
  const config = {
    URL: 'https://dev.trade-tariff.service.gov.uk/uk/api/v2/headings/0104',
    TOTAL_REQUESTS_PER_CONCURRENCY: 100,
    MIN_CONCURRENCY: 1,
    MAX_CONCURRENCY: 10,
    REFILL_WAIT_SECONDS: 130,
    LIMITER_TYPES: [
      { name: 'Hybrid V2', headerValue: 'reduced-atomicity-hybrid-v2' },
      { name: 'Hybrid V1', headerValue: 'reduced-atomicity-hybrid-v1' },
      // { name: 'Atomic', headerValue: 'fully-atomic-dynamo' },
    ],
  };

  async function main() {
    console.log(chalk.bold.yellow('Starting Rate Limiter Performance & Collision Test'));
    const runId = uuidv4().split('-')[0];
    console.log(chalk.gray(`   Test Run ID: ${runId}`));

    const token = await getAuthToken();
    const baseHeaders = { Authorization: token, 'x-client-id': `validation-run-${runId}` };

    await performSanityCheck(baseHeaders);

    const allResults = [];
    const allErrorSamples = [];
    for (const [index, limiter] of config.LIMITER_TYPES.entries()) {
      if (index > 0) {
        await waitForRefill();
      }
      const { results: limiterResults, errorSamples } = await runTestsForLimiter(limiter, baseHeaders);
      allResults.push(...limiterResults);
      allErrorSamples.push(...errorSamples);
    }

    console.log(chalk.bold.yellow('\nðŸ“Š ABA Collision Test Results:'));
    printResultsTable(allResults);

    if (allErrorSamples.length > 0) {
      console.log(chalk.bold.yellow('\nðŸ”¬ Sampled Errors:'));
      printErrorSamplesTable(allErrorSamples);
    }
  }

  // --- Helper Functions ---

  async function getAuthToken() {
    const spinner = ora('Fetching authentication token...').start();
    try {
      const token = execSync('.github/bin/get-access-token').toString().trim();
      spinner.succeed('Authentication token fetched.');
      return token;
    } catch (e) {
      spinner.fail('Failed to get authentication token.');
      console.error(chalk.red(e));
      process.exit(1);
    }
  }

  async function performSanityCheck(baseHeaders) {
    console.log(chalk.bold.cyan('\nðŸ” Performing Sanity Checks...'));
    const spinner = ora('Running initial requests...').start();
    for (const limiter of config.LIMITER_TYPES) {
      spinner.text = `Checking ${limiter.name}...`;
      try {
        const headers = { ...baseHeaders, 'x-rate-limiter': limiter.headerValue };
        const response = await axios.head(config.URL, { headers });
        const limit = response.headers['x-ratelimit-limit'];
        const remaining = response.headers['x-ratelimit-remaining'];
        spinner.succeed(chalk.green(`${limiter.name}: OK (Limit: ${limit}, Remaining: ${remaining})`));
      } catch (e) {
        spinner.fail(chalk.red(`${limiter.name}: Failed! ${e.message}`));
        process.exit(1);
      }
    }
  }

  async function waitForRefill() {
    console.log(chalk.bold.cyan(`\nâ³ Waiting for token bucket to refill...`));
    const spinner = ora({ text: `${config.REFILL_WAIT_SECONDS}s remaining`, color: 'blue' }).start();
    for (let i = config.REFILL_WAIT_SECONDS; i > 0; i--) {
      spinner.text = `${i}s remaining...`;
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    spinner.succeed('Token bucket refilled.');
  }

  async function runTestsForLimiter(limiter, baseHeaders) {
    console.log(chalk.bold.cyan(`\nðŸ”¥ Stress Testing: ${limiter.name}`));
    const headers = { ...baseHeaders, 'x-rate-limiter': limiter.headerValue };
    const results = [];
    const errorSamples = [];

    for (let concurrency = config.MIN_CONCURRENCY; concurrency <= config.MAX_CONCURRENCY; concurrency++) {
      const spinner = ora(`Running with concurrency ${concurrency}...`).start();
      const stats = {
        success: 0,
        collision_429: 0,
        normal_429: 0,
        other_error: 0,
        allowed_times: [],
        denied_times: [],
      };
      const totalRequests = config.TOTAL_REQUESTS_PER_CONCURRENCY;
      const chunks = Math.ceil(totalRequests / concurrency);

      for (let i = 0; i < chunks; i++) {
        const promises = [];
        for (let j = 0; j < concurrency && (i * concurrency + j) < totalRequests; j++) {
          promises.push(makeRequest(headers));
        }
        const chunkResults = await Promise.all(promises);
        chunkResults.forEach(result => {
          if (result.is_other_error) {
            if (stats.other_error < 10) { // Sample up to 10 errors
              errorSamples.push({ limiterName: limiter.name, concurrency, message: result.errorMessage });
            }
            stats.other_error++;
          } else if (result.is_429) {
            stats.denied_times.push(result.time);
            if (result.collision) stats.collision_429++;
            else stats.normal_429++;
          } else {
            stats.allowed_times.push(result.time);
            stats.success++;
          }
        });
      }

      spinner.stop();
      const avgAllowedTime = stats.allowed_times.reduce((a, b) => a + b, 0) / (stats.allowed_times.length || 1);
      const avgDeniedTime = stats.denied_times.reduce((a, b) => a + b, 0) / (stats.denied_times.length || 1);

      results.push({
        limiterName: limiter.name,
        concurrency,
        allowedPct: (stats.success / totalRequests) * 100,
        avgAllowedTime,
        avgDeniedTime,
        deniedCount: stats.denied_times.length,
        collision429Pct: (stats.collision_429 / totalRequests) * 100,
        normal429Pct: (stats.normal_429 / totalRequests) * 100,
        errorPct: (stats.other_error / totalRequests) * 100,
      });
    }
    return { results, errorSamples };
  }

  async function makeRequest(headers) {
    const startTime = performance.now();
    try {
      const response = await axios.head(config.URL, { headers });
      const collision = response.headers['x-ratelimit-collision']?.toLowerCase() === 'true';
      return { time: performance.now() - startTime, is_429: false, collision, is_other_error: false };
    } catch (error) {
      const time = performance.now() - startTime;
      if (error.response && error.response.status === 429) {
        const collision = error.response.headers['x-ratelimit-collision']?.toLowerCase() === 'true';
        return { time, is_429: true, collision, is_other_error: false };
      }
      return { time, is_429: false, collision: false, is_other_error: true, errorMessage: error.message };
    }
  }

  function printResultsTable(results) {
    const header = [
      'Limiter', 'Concurrency', 'Allowed %', 'Avg Time (Allow)', 'Avg Time (Deny)', '429 Collision %', '429 Normal %', 'Error %'
    ].map(h => chalk.bold.white(h));

    const tableData = results.map(r => [
      chalk.cyan(r.limiterName),
      r.concurrency,
      `${r.allowedPct.toFixed(2)}%`,
      `${r.avgAllowedTime.toFixed(2)} ms`,
      chalk[r.deniedCount > 0 ? 'yellow' : 'gray'](`${r.avgDeniedTime.toFixed(2)} ms`),
      chalk[r.collision429Pct > 0 ? 'red' : 'green'](`${r.collision429Pct.toFixed(2)}%`),
      `${r.normal429Pct.toFixed(2)}%`,
      chalk[r.errorPct > 0 ? 'yellow' : 'white'](`${r.errorPct.toFixed(2)}%`),
    ]);

    console.log(table([header, ...tableData]));
  }

  function printErrorSamplesTable(errorSamples) {
    const header = ['Limiter', 'Concurrency', 'Sampled Error Message'].map(h => chalk.bold.white(h));
    const tableData = errorSamples.map(e => [
      chalk.cyan(e.limiterName),
      e.concurrency,
      chalk.red(e.message),
    ]);
    console.log(table([header, ...tableData]));
  }

  main().catch(err => {
    console.error(chalk.red.bold('\nAn unexpected error occurred:'));
    console.error(err);
    process.exit(1);
  });

})();
